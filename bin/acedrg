#!/usr/bin/env python
# Python script
#
#
#
#     Copyright (C) 2014 --- 2019 Fei Long,  Murshudov
#
#     This code is distributed under the terms and conditions of the
#     CCP4 Program Suite Licence Agreement as a CCP4 Library.
#
#====================================================================
## The date of last modification: 11/07/2014

import os,os.path,sys
import glob,shutil
import re,string
from optparse import OptionParser 
import time

if not os.environ.has_key("CCP4") :
    print "Please activate ccp4.setup"
    sys.exit() 

class Acedrg:

    def __init__( self, t_argvs):

        self.errMessage       = []
        self.errLevel         = 0

        self.inStdCifName     = ""
        self.inMmCifName      = ""
        self.inSmiName        = ""
        self.inMdlName        = ""
        self.inPdbName        = ""
        self.inSDFName        = ""
        self.outRoot          = ""
        self.outRstCifName    = ""
        self.outRstPdb        = ""
        self.monomRoot        = ""

        self.acedrgTables      = ""
        self.libmol           = ""
        self.libmolLogName    = ""
        self.libcheck         = ""
        self.libcheckLogName  = ""
        self.refmac           = ""
        self.refmacLogName    = ""

        self.cmdLine          = ""
        self.workMode         = 0


        self.molGen           = False
        self.repCrds          = False

        inputOptionsP         = self.InputParser(t_argvs) 
        self.setWorkMode(inputOptionsP)
        self.checkDependency()
       
        self.execute()  

    def InputParser(self, t_argvs):

        usage = "Look for help: %s -h "%"acedrg"

        self.inputParser = OptionParser(usage=usage)

        # Options 
        # input file format 
        self.inputParser.add_option("-b",  "--stdcif", dest="inStdCifName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input small molecule CIF File containing coordinates and crystal information")

        self.inputParser.add_option("-c",  "--mmcif", dest="inMmCifName", metavar="FILE", 
                                    action="store", type="string", help="Input MMCIF File containing coordinates and bonds")

        self.inputParser.add_option("-e",  "--molgen", dest="molGen",  
                                    action="store_true",  default=False,  
                                    help="The option when the user want to generate molecules and values of the associated bonds and angles in a cif file")

        self.inputParser.add_option("-i",  "--smi", dest="inSmiName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input  File containing a SMILE string")

        self.inputParser.add_option("-m",  "--mdl", dest="inMdlName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input File of MDL format containing coordinates and bonds")

        self.inputParser.add_option("-o",  "--out", dest="outRoot", 
                                    action="store", type="string", 
                                    help="A name root that users want their output files called(without extension)")

        self.inputParser.add_option("-p",  "--pdb", dest="inPdbName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input File of PDB format containing atomic coordinates ")

        self.inputParser.add_option("-r",  "--res", dest="monomRoot",  
                                    action="store", type="string", 
                                    help="The name of the chemical components users want to put into output files(e.g. PDB or MMCIF)")

        self.inputParser.add_option("-s",  "--sdf", dest="inSdfName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input File of SDF format containing coordinates and bonds")

        self.inputParser.add_option("-t",  "--tab", dest="acedrgTables", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input path that stores all bond and angle tables (if no input, default CCP4 location will be used)")

        self.inputParser.add_option("-y", "--repcrd",
                  action="store_true", dest="repCrd", default=False,
                  help="Use this keyword if you want to replace the atomic coordinates in the input mmCif with those in the input PDB")

        (inputOptionsP, inputOptionsU) = self.inputParser.parse_args(t_argvs)

        if inputOptionsU:    
            print "Line arguments for those keywords are missing "
            for a_opt in inputOptionsU:
                print "Keyword %s ?"%a_opt
            sys.exit()

        return inputOptionsP 

    def checkDependency(self):
     
        if os.environ.has_key("CCP4"):
            tRefmac = os.path.join(os.environ['CBIN'], "refmac5")
            if not glob.glob(tRefmac):
                print "refmac5 could not be found"
                sys.exit()
            else:
                self.refmac = tRefmac

            tLibcheck = os.path.join(os.environ['CBIN'], "libcheck")
            if not glob.glob(tLibcheck):
                print "libcheck could not be found"
                sys.exit()
            else:
                self.libcheck = tLibcheck

            tLibmol = os.path.join(os.environ['CCP4'], "libexec", "libmol")
            if glob.glob(tLibmol):
                self.libmol = tLibmol

            tAcedrgTables = os.path.join(os.environ['CCP4'], "share/acedrg/tables")
            if glob.glob(tAcedrgTables):
                self.acedrgTables = tAcedrgTables
        else :
            print "You need to install CCP4 suite"
            sys.exit()

        if not self.libmol :
            if os.environ.has_key("LIBMOL_ROOT"):
                tLibmol = os.path.join(os.environ['LIBMOL_ROOT'], "bin/libmol")
                if glob.glob(tLibmol):
                    self.libmol = tLibmol
                else:
                    print "libmol could not be found at %s"%tLibmol
                    sys.exit()
            else:
                print "You need to define the path where the acedrg tables are or install the latest version of CCP4 with acedrg  "
                sys.exit()
                                

        if not self.acedrgTables:
            if os.environ.has_key("LIBMOL_ROOT"):
                tAcedrgTables = os.path.join(os.environ['LIBMOL_ROOT'], "tables")
                if os.path.isdir(tAcedrgTables):
                    self.acedrgTables = tAcedrgTables
                else:
                    print "Tables required could not be found at %s"%tAcedrgTables
                    sys.exit()
            else:
                print "You need to define the path where the acedrg tables are or install the latest version of CCP4 with acedrg  "
                sys.exit()
                                
    def setWorkMode(self, t_inputOptionsP = None):
 
        if not t_inputOptionsP.acedrgTables: 
            if os.environ.has_key("CCP4"):
                tAcedrgTables = os.path.join(os.environ['CCP4'], "share/acedrg/tables")
                if glob.glob(tAcedrgTables):
                    self.acedrgTables = tAcedrgTables
            else:
                print "You need to install CCP4 suite"
                sys.exit()
        else:
            if os.path.isdir(t_inputOptionsP.acedrgTables):
                self.acedrgTables = t_inputOptionsP.acedrgTables
 
        if not self.acedrgTables or not glob.glob(self.acedrgTables):
            if os.environ.has_key("LIBMOL_ROOT"):
                tAcedrgTables = os.path.join(os.environ['LIBMOL_ROOT'], "tables")
                if os.path.isdir(tAcedrgTables):
                    self.acedrgTables = tAcedrgTables
                else:
                    print "Bond and angle tables required could not be found "
                    sys.exit()
                     
        if t_inputOptionsP.inMmCifName and not t_inputOptionsP.repCrd : 
            self.inMmCifName = t_inputOptionsP.inMmCifName
            self.workMode    = 11            
        elif t_inputOptionsP.inSmiName: 
            self.inSmiName = t_inputOptionsP.inSmiName
            self.workMode    = 12            
        elif t_inputOptionsP.inMdlName: 
            self.inMdlName = t_inputOptionsP.inMdlName
            self.workMode    = 13
        elif t_inputOptionsP.inSdfName: 
            self.inSdfName = t_inputOptionsP.inSdfName
            self.workMode    = 14
        elif t_inputOptionsP.molGen and t_inputOptionsP.inStdCifName: 
            self.inStdCifName = t_inputOptionsP.inStdCifName
            self.workMode     = 21
        elif t_inputOptionsP.repCrd and t_inputOptionsP.inPdbName and t_inputOptionsP.inMmCifName: 
            self.inMmCifName = t_inputOptionsP.inMmCifName
            self.inPdbName = t_inputOptionsP.inPdbName
            self.workMode     = 41
                        
        if t_inputOptionsP.monomRoot:
            self.monomRoot   = t_inputOptionsP.monomRoot
        else:
            self.monomRoot   = "UNL"

        if t_inputOptionsP.outRoot:
            self.outRoot   = t_inputOptionsP.outRoot
        else:
            self.outRoot   = "AcedrgOut"

    def runLibmol(self, tIn=None):
 
        self.cmdLine = self.libmol
        if self.workMode == 11 or self.workMode == 12:
            if tIn:
                self.inMmCifName    = tIn
            
            self.libmolLogName  = self.outRoot + ".log"
            self.outRstCifName  = self.outRoot + "_cod.rst"   
            self.outRstPdbName  = self.outRoot + "_cod.pdb"

            self.cmdLine +=" -c %s  "%self.inMmCifName
            self.cmdLine += " -r %s -o %s >& %s "%(self.monomRoot, self.outRstCifName, self.libmolLogName)
            os.system(self.cmdLine)
        if self.workMode == 13 or self.workMode == 14:
            if tIn:
                self.inMmCifName = tIn
            self.libmolLogName  = self.outRoot + ".log"
            self.outRstCifName  = self.outRoot + "_cod.rst"
            self.outRstPdbName  = self.outRoot + "_cod.pdb"

            self.cmdLine += " -s %s  "%self.inMmCifName
            self.cmdLine += " -r %s -o %s >& %s "%(self.monomRoot, self.outRstCifName, self.libmolLogName)
            os.system(self.cmdLine)

        if self.workMode == 21 :
            if tIn:
                self.inStdCifName = tIn

            self.libmolLogName  = self.outRoot + ".log"
            self.outRstCifName  = self.outRoot + ".rst"
	    self.outMolsName    = self.monomRoot + "_all_mols.txt"
            self.outBondsAndAnglesName  = self.monomRoot + "_unique_bond_and_angles.txt"

            self.cmdLine += " -b %s  "%self.inStdCifName
            self.cmdLine += " -m yes -r %s -o %s >  %s "%(self.monomRoot, self.outRstCifName, self.libmolLogName)
            print self.cmdLine
            os.system(self.cmdLine)

        if self.workMode == 41 :

            self.libmolLogName  = self.outRoot + ".log"
            self.cmdLine += " -p %s -c %s "%(self.inPdbName, self.inMmCifName)
            self.cmdLine += " -y y -o %s >>  %s "%(self.outRstCifName, self.libmolLogName)
            print self.cmdLine
            os.system(self.cmdLine)

             
    def setLibcheckBat(self, tSmiName, tOutRoot, tLogNme):

        self.cmdLine = self.libcheck 

        libcheckBatName = self.outRoot + "_libcheck.bat"
        try:
            libcheckBat = open(libcheckBatName,"w")
        except IOError:
            print libcheckBatName, " could not be opened for write "
            sys.exit()
        else:
            libcheckBat.write(" N \n")
            libcheckBat.write("FILE_SMILE %s\n"%tSmiName) 
            libcheckBat.write("FILE_O  %s \n\n"%tOutRoot)
            libcheckBat.close()

            self.cmdLine +=" < %s > %s"%(libcheckBatName, tLogNme)
            #print self.cmdLine
    
    def runLibcheck(self, tSmiName=None):

        if tSmiName:
            self.inSmiName = tSmiName
        self.libcheckLogName  = self.outRoot + "_libcheck.log"
        self.libcheckOutRoot  = self.outRoot + "_libcheck"
        self.libcheckLibName  = self.libcheckOutRoot +".lib"
        self.setLibcheckBat(self.inSmiName,  self.libcheckOutRoot, self.libcheckLogName)
        os.system(self.cmdLine)
            
    def setRefmacCom(self, tPdbIn, tLibIn, tPdbOut, tLogName, tStage=2):
     
        self.cmdLine = self.refmac 
        if tStage==1:
            self.cmdLine += "  xyzin %s libin %s xyzout %s <<eof > %s  \n"%(tPdbIn, tLibIn, tPdbOut, tLogName) 
            self.cmdLine += "end       \n"
	    self.cmdLine += "eof       \n\n"
        elif tStage==2: 
            self.cmdLine += "  xyzin %s libin %s xyzout %s <<eof > %s  \n"%(tPdbIn, tLibIn, tPdbOut, tLogName)  
            self.cmdLine += "mode newe \n"
            self.cmdLine += "end       \n"
	    self.cmdLine += "eof       \n\n"
        elif tStage==3: 
            self.cmdLine += "  xyzin %s libin %s xyzout %s <<eof > %s  \n"%(tPdbIn, tLibIn, tPdbOut, tLogName)  
            self.cmdLine += "ncyc 1    \n"
            self.cmdLine += "end       \n"
	    self.cmdLine += "eof       \n\n"
        elif tStage==4: 
            self.cmdLine += "  xyzin %s libin %s xyzout %s <<eof > %s  \n"%(tPdbIn, tLibIn, tPdbOut, tLogName)  
            self.cmdLine += "make hout yes    \n"
            self.cmdLine += "ncyc 40    \n"
            self.cmdLine += "end       \n"
	    self.cmdLine += "eof       \n\n"
        else: 
            self.cmdLine += "  xyzin %s libin %s xyzout %s <<eof > %s  \n"%(tPdbIn, tLibIn, tPdbOut, tLogName)  
            self.cmdLine += "mode newe \n"
            self.cmdLine += "end       \n"
	    self.cmdLine += "eof       \n\n"
        #print self.cmdLine

    def runRefmac(self, tPdbIn, tLibIn, tStage=2):
      
        print "Run Refmac at stgae ", tStage
        self.refmacLogName    = self.outRoot + "_refmac_stage_"+ str(tStage) + ".log"
        self.refmacXYZOUTName = self.outRoot + "_refmac_stage_"+ str(tStage) + ".pdb"
        self.setRefmacCom(tPdbIn, tLibIn, self.refmacXYZOUTName, self.refmacLogName, tStage)
        os.system(self.cmdLine)

    def transCoordsPdbToCif(self, tPdbInName, tCifInName, tCifOutName):

        cifCont = {}
        cifCont['head']   = []
        cifCont['atoms']  = []
        cifCont['others'] = []
        pdbAtoms = {}
        try:
            tPdbIn = open(tPdbInName, "r")
        except IOError:
            print "%s can not be opened for reading"%tPdbInName
            sys.exit()
        else:
            try: 
                tCifIn = open(tCifInName, "r")
            except IOError:
                print "%s can not be opened for reading"%tCifInName
                sys.exit()
            else:
                allPdbLines  = tPdbIn.readlines()
                tPdbIn.close()
                for aLine in allPdbLines:
                    aLine = aLine.strip()
                    if aLine.find("ATOM") !=-1 or aLine.find("HETATM") !=-1 :
                        tName = aLine[12:16].strip()
                        tX    = aLine[30:38].strip()
                        tY    = aLine[38:46].strip()
                        tZ    = aLine[46:54].strip()
                        pdbAtoms[tName] = []
                        pdbAtoms[tName].append(tX)
                        pdbAtoms[tName].append(tY)
                        pdbAtoms[tName].append(tZ)

                allCifLines = tCifIn.readlines()
                tCifIn.close()
                lStart = True
                lAtom  = False
                lOther = False

                for aLine in allCifLines:
                    if aLine.find("_chem_comp_atom.z") != -1:
                        cifCont['head'].append(aLine)
                        lStart = False
                        lAtom  = True
                    elif lAtom and aLine.find("loop") != -1:
                        lAtom  = False
                        lOther = True
                        cifCont['others'].append(aLine)
                    elif lStart:  
                        cifCont['head'].append(aLine)
                    elif lAtom:
                        strGrp = aLine.split()
                        tName  = strGrp[1].strip()
                        if pdbAtoms.has_key(tName):
                            bLine = "%s%s%s%s%s%s%s%s\n"%(strGrp[0].ljust(8), tName.ljust(8), strGrp[2].ljust(8), \
                                                        strGrp[3].ljust(8), strGrp[4].ljust(8), \
                                                        pdbAtoms[tName][0].ljust(12), pdbAtoms[tName][1].ljust(12), \
                                                        pdbAtoms[tName][2].ljust(12)) 
                            cifCont['atoms'].append(bLine)
                        else: 
                            print "Bug. can not find atom %s in Pdb file %s "%(tName, tPdbInName) 
                            sys.exit()
                    elif lOther:
                        cifCont['others'].append(aLine)
  
                try:
                    tOutCif = open(tCifOutName, "w")
                except IOError:
                    print "%s can not be opened for reading"%tCifOutName
                    sys.exit()
                else:
                    for aL in cifCont['head']:
                        tOutCif.write(aL)
                    for aL in cifCont['atoms']:
                        tOutCif.write(aL)
                    for aL in cifCont['others']:
                        tOutCif.write(aL)
                    tOutCif.close()
                        
    def execute(self):
       
        print "Current workMode ", self.workMode
        
        if self.workMode == 11:

            # Stage 1: dictionary generation using a mmcif file 
            if os.path.isfile(self.inMmCifName):
                self.runLibmol(self.inMmCifName)
            else:
                print "%s does not exist"%self.inMmCifName
                sys.exit()

            # Stage 2: optimization
            if os.path.isfile(self.outRstCifName) and os.path.isfile(self.outRstPdbName):
                if os.path.getsize(self.outRstPdbName) > 1000 and os.path.getsize(self.outRstCifName) > 500:
                    stageNow = 1
                    self.runRefmac(self.outRstPdbName, self.outRstCifName, stageNow)
                    if os.path.isfile(self.refmacXYZOUTName):
                        tPdb1 = self.refmacXYZOUTName
                        stageNow = 2
                        self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                        if os.path.isfile(self.refmacXYZOUTName):
                            tPdb1 = self.refmacXYZOUTName
                            stageNow = 3
                            self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                            if os.path.isfile(self.refmacXYZOUTName):
                                tPdb1 = self.refmacXYZOUTName
                                stageNow = 4
                                self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                                if os.path.isfile(self.refmacXYZOUTName):
                                     finPdb = self.outRoot + ".pdb"
                                     finRst = self.outRoot + ".cif"
                                     os.system("cp %s   %s "%(self.refmacXYZOUTName, finPdb))
                                     #os.system("cp %s   %s "%(self.outRstCifName, finRst))
                                     if os.path.isfile(finPdb):
                                         self.inPdbName        = finPdb 
                                         self.inMmCifName      = self.outRstCifName
                                         self.outRstCifName    = finRst
                                         self.transCoordsPdbToCif(self.inPdbName, self.inMmCifName, self.outRstCifName)
                                     else:
                                         print "Failed to produce %s "%finPdb
                                else:
                                     print "Failed to produce the final coordinates" 
                        
    
        if self.workMode == 12:
            
            # Stage 1: Transfer the SMILE input into a mmcif file
            if os.path.isfile(self.inSmiName):
                self.runLibcheck(self.inSmiName)
            else:
                print "%s does not exist"%self.inSmiName
                sys.exit()

            # Stage 2: dictionary generation using a mmcif file
            if os.path.isfile(self.libcheckLibName):
                self.runLibmol(self.libcheckLibName)
            else:
                print "%s does not exist"%self.inMmCifName
                sys.exit()

            # Stage 3: optimization
            if os.path.isfile(self.outRstCifName) and os.path.isfile(self.outRstPdbName):
                if os.path.getsize(self.outRstPdbName) > 1000 and os.path.getsize(self.outRstCifName) > 500:
                    #self.runRefmac(self.outRstPdbName, self.outRstCifName)
                    stageNow = 1
                    self.runRefmac(self.outRstPdbName, self.outRstCifName, stageNow)
                    if os.path.isfile(self.refmacXYZOUTName):
                        tPdb1 = self.refmacXYZOUTName
                        stageNow = 2
                        self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                        if os.path.isfile(self.refmacXYZOUTName):
                            tPdb1 = self.refmacXYZOUTName
                            stageNow = 3
                            self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                            if os.path.isfile(self.refmacXYZOUTName):
                                tPdb1 = self.refmacXYZOUTName
                                stageNow = 4
                                self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                                if os.path.isfile(self.refmacXYZOUTName):
                                     finPdb = self.outRoot + ".pdb"
                                     finRst = self.outRoot + ".cif"
                                     os.system("cp %s   %s "%(self.refmacXYZOUTName, finPdb))
                                     #os.system("cp %s   %s "%(self.outRstCifName, finRst))
                                     if os.path.isfile(finPdb):
                                         self.inPdbName        = finPdb 
                                         self.inMmCifName      = self.outRstCifName
                                         self.outRstCifName    = finRst
                                         self.transCoordsPdbToCif(self.inPdbName, self.inMmCifName, self.outRstCifName)
                                     else:
                                         print "Failed to produce %s "%finPdb
                                else:
                                     print "Failed to produce the final coordinates" 
                else:
                    print "%s or %s does not contain enough information "%(self.outRstPdbName, self.outRstCifName)
            else:
                print "%s and/or %s do not exist "%(self.outRstPdbName, self.outRstCifName)

        if self.workMode == 13:
            
            # Stage 1: dictionary generation using  a mdl file
            if os.path.isfile(self.inMdlName):
                self.runLibmol(self.inMdlName)
                print "Dictionary output %s"%self.outRstCifName
                print "PDB output %s"%self.outRstPdbName
            else:
                print "can not find %s to read "%self.inMdlName
                sys.exit() 
 
            # Stage 2: optimization
            if os.path.isfile(self.outRstCifName) and os.path.isfile(self.outRstPdbName):
                if os.path.getsize(self.outRstPdbName) > 1000 and os.path.getsize(self.outRstCifName) > 500:
                    # self.runRefmac(self.outRstPdbName, self.outRstCifName)
                    stageNow = 1
                    self.runRefmac(self.outRstPdbName, self.outRstCifName, stageNow)
                    if os.path.isfile(self.refmacXYZOUTName):
                        tPdb1 = self.refmacXYZOUTName
                        stageNow = 2
                        self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                        if os.path.isfile(self.refmacXYZOUTName):
                            tPdb1 = self.refmacXYZOUTName
                            stageNow = 3
                            self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                            if os.path.isfile(self.refmacXYZOUTName):
                                tPdb1 = self.refmacXYZOUTName
                                stageNow = 4
                                self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                                if os.path.isfile(self.refmacXYZOUTName):
                                     finPdb = self.outRoot + ".pdb"
                                     finRst = self.outRoot + ".cif"
                                     os.system("cp %s   %s "%(self.refmacXYZOUTName, finPdb))
                                     os.system("cp %s   %s "%(self.outRstCifName, finRst))
                                     if os.path.isfile(finPdb):
                                         self.inPdbName        = finPdb 
                                         self.inMmCifName      = self.outRstCifName
                                         self.outRstCifName    = finRst
                                         self.transCoordsPdbToCif(self.inPdbName, self.inMmCifName, self.outRstCifName)
                                     else:
                                         print "Failed to produce %s "%finPdb
                                else:
                                     print "Failed to produce the final coordinates" 
    
        if self.workMode == 14:
            
            # Stage 1: dictionary generation using  a sdf file
            if os.path.isfile(self.inSdfName):
                self.runLibmol(self.inSdfName)
            else:
                print "%s does not exist"%self.inSdfName
                sys.exit()
            
            # Stage 2: optimization
            if os.path.isfile(self.outRstCifName) and os.path.isfile(self.outRstPdbName):
                if os.path.getsize(self.outRstPdbName) > 1000 and os.path.getsize(self.outRstCifName) > 500:
                    #self.runRefmac(self.outRstPdbName, self.outRstCifName)
                    stageNow = 1
                    self.runRefmac(self.outRstPdbName, self.outRstCifName, stageNow)
                    if os.path.isfile(self.refmacXYZOUTName):
                        tPdb1 = self.refmacXYZOUTName
                        stageNow = 2
                        self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                        if os.path.isfile(self.refmacXYZOUTName):
                            tPdb1 = self.refmacXYZOUTName
                            stageNow = 3
                            self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                            if os.path.isfile(self.refmacXYZOUTName):
                                tPdb1 = self.refmacXYZOUTName
                                stageNow = 4
                                self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                                if os.path.isfile(self.refmacXYZOUTName):
                                     finPdb = self.outRoot + ".pdb"
                                     os.system("cp %s   %s "%(self.refmacXYZOUTName, finPdb))
                                     if os.path.isfile(finPdb):
                                         self.inPdbName        = finPdb 
                                         self.inMmCifName      = self.outRstCifName
                                         self.outRstCifName    = finRst
                                         self.transCoordsPdbToCif(self.inPdbName, self.inMmCifName, self.outRstCifName)
                                     else:
                                         print "Failed to produce %s "%finPdb
                                else:
                                     print "Failed to produce the final coordinates" 

        if self.workMode == 21:
            
            # Stage 1: generate molecules and the associated bond and bond-angle values 
            # using a small molecule cif file
            print "Generate molecules, bonds and angles from small molecule CIF file ", self.inStdCifName 
            if os.path.isfile(self.inStdCifName):
                self.runLibmol(self.inStdCifName)
            else:
                print "Can not find the input file ", self.inStdCifName 
            

def main():
    acedrgObj = Acedrg(sys.argv[1:])

if __name__ == "__main__":
    main()

