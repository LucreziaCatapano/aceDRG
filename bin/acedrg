#!/usr/bin/env python
# Python script
#
#
#
#     Copyright (C) 2014 --- 2019 Fei Long,  Murshudov
#
#     This code is distributed under the terms and conditions of the
#     CCP4 Program Suite Licence Agreement as a CCP4 Library.
#
#====================================================================
## The date of last modification: 11/07/2014

import os,os.path,sys
import glob,shutil
import re,string
from optparse import OptionParser 
import time
import math
import select, fcntl
import signal

if not os.environ.has_key("CCP4") :
    print "Please activate ccp4.setup"
    sys.exit() 


#################################################   

class CExeCode :
    """ A generic abstract base class that is to be inheritted by other classes that warp 
        a executable code. Basically this class defines two main methods that characterize the
        procedures a job by an executable code, i.e.  forming a command line object and then
        run the code according to the command line object"""

    def __init__( self ):

        # set pathes
 
        self.exitCode = 0

        # test 
        self._setCmdLineAndFile()

    def _setCmdLineAndFile(self ):         # will be overrided by individual derived classes
        self._cmdline = 'ls '
        self.batch_name = None
        self._log_name = None
            
    def subExecute(self, mode = 0, err_str ="" ):

        if self._log_name :
            self.logMode(mode, err_str)
        else :
            self.interactiveMode()

    def logMode(self, mode = 0, err_str=""):
        """ execute self._cmdline and output to a log file (self._log_name)  
        in a nonblocking way"""

        logfile = open(self._log_name, 'w')
        logfile.write("\n============ PROCESS INFORMATION =============\n")

        # spawn a sub-process for a job and connect to its input/output(and error)
        # streams using pipes

        try : 
            import subprocess
            subProcess = subprocess.Popen(self._cmdline, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
            subProcess.stdin.close()
            outfile_sub  = subProcess.stdout
            outfd_sub    = outfile_sub.fileno()
        except ImportError:
            print "module 'subprocess' has not be found, you use a version of PYTHON below 2.4"
            print "BALBES import module 'popen2' instead, the calculations will not be affected"
            import popen2
            subProcess = popen2.Popen4(self._cmdline)
            subProcess.tochild.close()
            outfile_sub  = subProcess.fromchild
            outfd_sub    = outfile_sub.fileno()
    
        self._pid  = subProcess.pid
        pid_c      = self._pid  + 1
        p_name = os.path.basename(self._cmdline.strip().split()[0])
        t__log_name = os.path.basename(self._log_name)
        
       
        log_size = 0 
        log_max  = 100000000
        outfile_eof = 0
        if not mode:
            self._nonBlockingFile(outfd_sub)
            while not outfile_eof :
                ready_to_read, ready_to_write, in_error = \
                     select.select([outfd_sub],[],[],60.0)
                if outfd_sub in ready_to_read:
                    out_quantum = outfile_sub.read()
                    out_quantum_bt = len(out_quantum)
                    log_size = log_size + out_quantum_bt
                    if log_size > log_max:
                        logfile.write("\nTHE SIZE OF LOG FILE, %s, EXCEEDED THE LIMIT AND PROCESS STOPPED\n"%t__log_name)
                        logfile.write("The process running %s is killed\n"%p_name)
                        logfile.close()
                        os.kill(self._pid, signal.SIGKILL)
                        os.kill(pid_c, signal.SIGKILL)
                        print "The process running %s is killed " %p_name
                        time.sleep(1.0)
                        # be safe stop all process
                        sys.exit(1)
                    else :
                        if out_quantum == '':
                            outfile_eof = 1
                        logfile.write(out_quantum)
                        logfile.flush()
        else :
            self._nonBlockingFile(outfd_sub)
            while not outfile_eof :
                ready_to_read, ready_to_write, in_error = \
                     select.select([outfd_sub],[],[],10)
                if outfd_sub in ready_to_read:
                    out_quantum = outfile_sub.read()
                    if out_quantum == '':
                        outfile_eof = 1
                    logfile.write(out_quantum)
                    logfile.flush()
                    # allProcInfo.append(out_quantum)

        self.exitCode = subProcess.wait()
      
        # if mode:
        #    for item in allProcInfo:
        #        logfile.write(item)

        logfile.write("=========END OF PROCESS INFORMATION\n ==========\n")
        logfile.close()

        outfile_sub.close()

        if self.exitCode:   
            print "#-----------------------------------------------------------#"
            print "The process stoped because of a runtime error in code '%s'!"%p_name
            if err_str:
                print "%s"%err_str
            else:
                print "See the associated log file '%s'."%t__log_name
            print "#-----------------------------------------------------------#"
            if not err_str:
                # if normal runtime errors, stop the program(using log. no err_str)  
                sys.exit(1)
                
        return True

    def _nonBlockingFile(self,fd):
        f_flag = fcntl.fcntl(fd, fcntl.F_GETFL,0)
        fcntl.fcntl(fd, fcntl.F_SETFL, f_flag | os.O_NONBLOCK)

    def interactiveMode(self):
        """ execute self._cmdline  just like what is done in a shell """
        
        os.system(self._cmdline)


# end


class Acedrg(CExeCode ):

    def __init__( self, t_argvs):

        self.errMessage       = []
        self.errLevel         = 0

        self.scrDir           = ""

        self.inStdCifName     = ""
        self.inMmCifName      = ""
        self.inSmiName        = ""
        self.inMdlName        = ""
        self.inPdbName        = ""
        self.inSDFName        = ""
        self.outRoot          = ""
        self.outRstCifName    = ""
        self.outRstPdb        = ""
        self.monomRoot        = ""

        self.acedrgTables      = ""
        self.libmol           = ""
        self.libmolLogName    = ""
        self.libcheck         = ""
        self.libcheckLogName  = ""
        self.refmac           = ""
        self.refmacLogName    = ""

        self.workMode         = 0


        self.molGen           = False
        self.repCrds          = False

        self.acedrg = os.path.abspath(sys.argv[0])
        self.acedrgDir = os.path.dirname(os.path.dirname(self.acedrg))
        #print self.acedrgDir
        inputOptionsP         = self.InputParser(t_argvs) 
        self.setWorkMode(inputOptionsP)
        self.checkDependency()
        self.execute()  

    def InputParser(self, t_argvs):

        usage = "Look for help: %s -h "%"acedrg"

        self.inputParser = OptionParser(usage=usage)

        # Options 
        # input file format 
        self.inputParser.add_option("-b",  "--stdcif", dest="inStdCifName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input small molecule CIF File containing coordinates and crystal information")

        self.inputParser.add_option("-c",  "--mmcif", dest="inMmCifName", metavar="FILE", 
                                    action="store", type="string", help="Input MMCIF File containing coordinates and bonds")

        self.inputParser.add_option("-e",  "--molgen", dest="molGen",  
                                    action="store_true",  default=False,  
                                    help="The option when the user want to generate molecules and values of the associated bonds and angles in a cif file")

        self.inputParser.add_option("-i",  "--smi", dest="inSmiName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input  File containing a SMILE string")

        self.inputParser.add_option("-m",  "--mol", dest="inMdlName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input File of MOL format containing coordinates and bonds")

        self.inputParser.add_option("-o",  "--out", dest="outRoot", 
                                    action="store", type="string", 
                                    help="A name root that users want their output files called(without extension)")

        self.inputParser.add_option("-p",  "--pdb", dest="inPdbName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input File of PDB format containing atomic coordinates ")

        self.inputParser.add_option("-r",  "--res", dest="monomRoot",  
                                    action="store", type="string", 
                                    help="The name of the chemical components users want to put into output files(e.g. PDB or MMCIF)")

        self.inputParser.add_option("-s",  "--sdf", dest="inSdfName", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input File of SDF format containing coordinates and bonds")

        self.inputParser.add_option("-t",  "--tab", dest="acedrgTables", metavar="FILE", 
                                    action="store", type="string", 
                                    help="Input path that stores all bond and angle tables (if no input, default CCP4 location will be used)")

        self.inputParser.add_option("-y", "--repcrd",
                  action="store_true", dest="repCrd", default=False,
                  help="Use this keyword if you want to replace the atomic coordinates in the input mmCif with those in the input PDB")

        (inputOptionsP, inputOptionsU) = self.inputParser.parse_args(t_argvs)

        if inputOptionsU:    
            print "Line arguments for those keywords are missing "
            for a_opt in inputOptionsU:
                print "Keyword %s ?"%a_opt
            sys.exit()

        return inputOptionsP 

    def checkDependency(self):
     
        if os.environ.has_key("CCP4"):
            tRefmac = os.path.join(os.environ['CBIN'], "refmac5")
            if not glob.glob(tRefmac):
                print "refmac5 could not be found"
                sys.exit()
            else:
                self.refmac = tRefmac

            tLibcheck = os.path.join(os.environ['CBIN'], "libcheck")
            if not glob.glob(tLibcheck):
                print "libcheck could not be found"
                sys.exit()
            else:
                self.libcheck = tLibcheck

            tLibmol = os.path.join(os.environ['CCP4'], "libexec", "libmol")
            if glob.glob(tLibmol):
                self.libmol = tLibmol

            tAcedrgTables = os.path.join(os.environ['CCP4'], "share/acedrg/tables")
            if glob.glob(tAcedrgTables):
                self.acedrgTables = tAcedrgTables
        else :
            print "You need to install CCP4 suite"
            sys.exit()

        if not self.libmol :
            if os.environ.has_key("LIBMOL_ROOT"):
                tLibmol = os.path.join(os.environ['LIBMOL_ROOT'], "libexec/libmol")
                if glob.glob(tLibmol):
                    self.libmol = tLibmol
                else:
                    print "libmol could not be found at %s"%tLibmol
                    sys.exit()

        if not self.libmol: 
            if glob.glob(self.acedrgDir):
               tLibmol = os.path.join(self.acedrgDir, "libexec/libmol")
               if glob.glob(tLibmol):
                   self.libmol = tLibmol
               else:
                   print "libmol could not be found at %s"%tLibmol
                   sys.exit()
            else:
                print "Can not find where the acedrg is installed"
                sys.exit()

        
        if not self.libmol: 
            print "can not find libmol at libexec/"
            sys.exit()
                                

        if not self.acedrgTables:
            if os.environ.has_key("LIBMOL_ROOT"):
                tAcedrgTables = os.path.join(os.environ['LIBMOL_ROOT'], "share/acedrg/tables")
                if os.path.isdir(tAcedrgTables):
                    self.acedrgTables = tAcedrgTables
                else:
                    print "Tables required could not be found at %s"%tAcedrgTables
                    sys.exit()
                                
        if not self.acedrgTables: 
            tAcedrgTables = os.path.join(self.acedrgDir, "share/acedrg/tables")
            print tAcedrgTables
            if os.path.isdir(tAcedrgTables):
                self.acedrgTables = tAcedrgTables
            else:
                print "Bond and angle tables required could not be found "
                sys.exit()
                     
    def setWorkMode(self, t_inputOptionsP = None):

        # Sequnence for check the locations of acedrg tables 
        # (1) Check if the user provides the location
        # (2) If not, check CCP4 suite default location.
        # (3) If not, check if the environment variable LIBMOL_ROOT is defined in the user's machine.
        # (4) If none of them, program exits.   
        if not t_inputOptionsP.acedrgTables: 
            if os.environ.has_key("CCP4"):
                tAcedrgTables = os.path.join(os.environ['CCP4'], "share/acedrg/tables")
                if glob.glob(tAcedrgTables):
                    self.acedrgTables = tAcedrgTables
            else:
                print "You need to install CCP4 suite"
                sys.exit()
        else:
            if os.path.isdir(t_inputOptionsP.acedrgTables):
                self.acedrgTables = t_inputOptionsP.acedrgTables
 
        if not self.acedrgTables or not glob.glob(self.acedrgTables):
            if os.environ.has_key("LIBMOL_ROOT"):
                tAcedrgTables = os.path.join(os.environ['LIBMOL_ROOT'], "share/acedrg/tables")
                print tAcedrgTables
                if os.path.isdir(tAcedrgTables):
                    self.acedrgTables = tAcedrgTables

        if not self.acedrgTables :
            
            tAcedrgTables = os.path.join(self.acedrgDir, "share/acedrg/tables")
            print tAcedrgTables
            if os.path.isdir(tAcedrgTables):
                self.acedrgTables = tAcedrgTables
            else:
                print "Bond and angle tables required could not be found "
                sys.exit()

        if t_inputOptionsP.inMmCifName and not t_inputOptionsP.repCrd : 
            self.inMmCifName = t_inputOptionsP.inMmCifName
            self.workMode    = 11            
        elif t_inputOptionsP.inSmiName: 
            self.inSmiName = t_inputOptionsP.inSmiName
            self.workMode    = 12            
        elif t_inputOptionsP.inMdlName: 
            self.inMdlName = t_inputOptionsP.inMdlName
            self.workMode    = 13
        elif t_inputOptionsP.inSdfName: 
            self.inSdfName = t_inputOptionsP.inSdfName
            self.workMode    = 14
        elif t_inputOptionsP.molGen and t_inputOptionsP.inStdCifName: 
            self.inStdCifName = t_inputOptionsP.inStdCifName
            self.workMode     = 21
        elif t_inputOptionsP.repCrd and t_inputOptionsP.inPdbName and t_inputOptionsP.inMmCifName: 
            self.inMmCifName = t_inputOptionsP.inMmCifName
            self.inPdbName = t_inputOptionsP.inPdbName
            self.workMode     = 41
                        
        if t_inputOptionsP.monomRoot:
            self.monomRoot   = t_inputOptionsP.monomRoot
        else:
            self.monomRoot   = "UNL"

        if t_inputOptionsP.outRoot:
            self.outRoot   = t_inputOptionsP.outRoot
        else:
            self.outRoot   = "AcedrgOut"

        self.scrDir = self.outRoot + "_TMP"
        if not os.path.isdir(self.scrDir):
            os.mkdir(self.scrDir)

    def printJobs(self):

        if self.workMode == 11 or self.workMode==12 or self.workMode ==13 or self.workMode==14:
            print "===================================================================" 
            print "| Your job is  generate the dictionary (cif) and coord(pdb) files |"
            print "| for your ligand and/or monomer                                  |"
            print "===================================================================" 
            if self.workMode==11:
                print "Input file: %s"%os.path.basename(self.inMmCifName)
            if self.workMode==12:
                print "Input file: %s"%os.path.basename(self.inSmiName)
            if self.workMode==13:
                print "Input file: %s"%os.path.basename(self.inMdlName)
            if self.workMode==14:
                print "Input file: %s"%os.path.basename(self.inSdfName)
            print "Output dictionary file: %s"%os.path.basename(self.outRoot + ".cif")
            print "Output coordinate file: %s"%os.path.basename(self.outRoot + ".pdb")

    def runLibmol(self, tIn=None):
 
        self._cmdline = self.libmol
        self._log_name       = os.path.join(self.scrDir, self.outRoot + "_cod.log")
        #print self._cmdline
        if self.workMode == 11 or self.workMode==12 or self.workMode ==13 or self.workMode==14:
            print "===================================================================" 
            print "| Generate the dictionary file using the internal database        |"
            print "===================================================================" 
            self.outRstCifName   = os.path.join(self.scrDir, self.outRoot + "_cod.rst")   
            self.outRstPdbName   = os.path.join(self.scrDir, self.outRoot + "_cod.pdb")
        if self.workMode == 11 or self.workMode == 12:
            if tIn:
                self.inMmCifName    = tIn
            self._cmdline +=" -c %s -D %s "%(self.inMmCifName, self.acedrgTables)
            self._cmdline += " -r %s -o %s "%(self.monomRoot, self.outRstCifName)
            #print self._cmdline
            #os.system(self._cmdline)
            self.subExecute()
        if self.workMode == 13 or self.workMode == 14:
            if tIn:
                self.inMmCifName = tIn
            self._cmdline += " -s %s  -D %s "%(self.inMmCifName, self.acedrgTables)
            self._cmdline += " -r %s -o %s "%(self.monomRoot, self.outRstCifName)
            #print self._cmdline
            #os.system(self._cmdline)
            self.subExecute()

        if self.workMode == 21 :
            if tIn:
                self.inStdCifName = tIn
            self.outRstCifName  = self.outRoot + ".rst"
	    self.outMolsName    = self.monomRoot + "_all_mols.txt"
            self.outBondsAndAnglesName  = self.monomRoot + "_unique_bond_and_angles.txt"

            self._cmdline += " -b %s  "%self.inStdCifName
            self._cmdline += " -m yes -r %s -o %s "%(self.monomRoot, self.outRstCifName)
            #print self.cmdline
            self.subExecute()

        if self.workMode == 41 :

            self._cmdline += " -p %s -c %s "%(self.inPdbName, self.inMmCifName)
            self._cmdline += " -y y -o %s "%(self.outRstCifName)
            #print self._cmdline
            self.subExecute()

             
    def setLibcheckBat(self, tSmiName, tOutRoot):

        self._cmdline = self.libcheck 

        libcheckBatName = os.path.join(self.scrDir, self.outRoot + "_libcheck.bat")
        try:
            libcheckBat = open(libcheckBatName,"w")
        except IOError:
            print libcheckBatName, " could not be opened for write "
            sys.exit()
        else:
            libcheckBat.write(" N \n")
            libcheckBat.write("FILE_SMILE %s\n"%tSmiName) 
            libcheckBat.write("FILE_O  %s \n\n"%tOutRoot)
            libcheckBat.close()

            self._cmdline +=" < %s "%(libcheckBatName)
            #print self.cmdline
    
    def runLibcheck(self, tSmiName=None):

        if tSmiName:
            self.inSmiName = tSmiName
        self._log_name        = os.path.join(self.scrDir, self.outRoot + "_libcheck.log")
        self.libcheckOutRoot  = os.path.join(self.scrDir, self.outRoot + "_libcheck")
        self.libcheckLibName  = self.libcheckOutRoot +".lib"
        self.setLibcheckBat(self.inSmiName,  self.libcheckOutRoot) 
        self.subExecute()
    
    def setRefmacCom(self, tPdbIn, tLibIn, tPdbOut, tStage=2):
     
        self._cmdline = self.refmac 
        if tStage==1:
            self._cmdline += "  xyzin %s libin %s xyzout %s <<eof\n"%(tPdbIn, tLibIn, tPdbOut) 
            self._cmdline += "end       \n"
	    self._cmdline += "eof       \n"
        elif tStage==2: 
            self._cmdline += "  xyzin %s libin %s xyzout %s <<eof\n"%(tPdbIn, tLibIn, tPdbOut)  
            self._cmdline += "mode newe \n"
            self._cmdline += "end       \n"
	    self._cmdline += "eof       \n"
        elif tStage==3: 
            self._cmdline += "  xyzin %s libin %s xyzout %s <<eof\n"%(tPdbIn, tLibIn, tPdbOut)  
            self._cmdline += "ncyc 1    \n"
            self._cmdline += "end       \n"
	    self._cmdline += "eof       \n"
        elif tStage==4: 
            self._cmdline += "  xyzin %s libin %s xyzout %s <<eof\n"%(tPdbIn, tLibIn, tPdbOut)  
            self._cmdline += "make hout yes    \n"
            self._cmdline += "ncyc 40    \n"
            self._cmdline += "end       \n"
	    self._cmdline += "eof       \n"
        else: 
            self._cmdline += "  xyzin %s libin %s xyzout %s <<eof\n"%(tPdbIn, tLibIn, tPdbOut)  
            self._cmdline += "mode newe \n"
            self._cmdline += "end       \n"
	    self._cmdline += "eof       \n"
        #print self._cmdline

    def runRefmac(self, tPdbIn, tLibIn, tStage=2):
      
        print "| Stage  %d        |"%tStage
        self._log_name    = os.path.join(self.scrDir, self.outRoot + "_refmac_stage_"+ str(tStage) + ".log")
        self.refmacXYZOUTName = os.path.join(self.scrDir, self.outRoot + "_refmac_stage_"+ str(tStage) + ".pdb")
        self.setRefmacCom(tPdbIn, tLibIn, self.refmacXYZOUTName, tStage)
        self.subExecute()
    
    def runGeoOpt(self):

        # Geometrical optimization
        if os.path.isfile(self.outRstCifName) and os.path.isfile(self.outRstPdbName):
            if os.path.getsize(self.outRstPdbName) > 1000 and os.path.getsize(self.outRstCifName) > 500:
                print "===================================================================" 
                print "| Geometrical Optimization                                        |"
                print "===================================================================" 
                stageNow = 1
                self.runRefmac(self.outRstPdbName, self.outRstCifName, stageNow)
                if os.path.isfile(self.refmacXYZOUTName):
                    tPdb1 = self.refmacXYZOUTName
                    stageNow = 2
                    self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                    if os.path.isfile(self.refmacXYZOUTName):
                        tPdb1 = self.refmacXYZOUTName
                        stageNow = 3
                        self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                        if os.path.isfile(self.refmacXYZOUTName):
                            tPdb1 = self.refmacXYZOUTName
                            stageNow = 4
                            self.runRefmac(tPdb1, self.outRstCifName, stageNow)
                            if os.path.isfile(self.refmacXYZOUTName):
                                finPdb = self.outRoot + ".pdb"
                                finRst = self.outRoot + ".cif"
                                os.system("cp %s   %s "%(self.refmacXYZOUTName, finPdb))
                                #os.system("cp %s   %s "%(self.outRstCifName, finRst))
                                if os.path.isfile(finPdb):
                                    self.inPdbName        = finPdb 
                                    self.inMmCifName      = self.outRstCifName
                                    self.outRstCifName    = finRst
                                    self.transCoordsPdbToCif(self.inPdbName, self.inMmCifName, self.outRstCifName)
                                    print "===================================================================" 
                                else:
                                    print "Failed to produce %s after final geometrical optimization"%finPdb
                            else:
                                print "Failed to produce the final coordinates at stage 4 optimization" 
                        else:
                            print "Failed to produce the  coordinates at stage 3 optimization" 
                    else:
                        print "Failed to produce the coordinates at stage 2 optimization" 
                else:
                    print "Failed to produce the coordinates at stage 1 optimization" 
            else:
                print "No dictionary file produced ! " 
        else:
            print "No dictionary file produced ! " 
                        
    def transCoordsPdbToCif(self, tPdbInName, tCifInName, tCifOutName):

        cifCont = {}
        cifCont['head']   = []
        cifCont['atoms']  = []
        cifCont['others'] = []
        pdbAtoms = {}
        try:
            tPdbIn = open(tPdbInName, "r")
        except IOError:
            print "%s can not be opened for reading"%tPdbInName
            sys.exit()
        else:
            try: 
                tCifIn = open(tCifInName, "r")
            except IOError:
                print "%s can not be opened for reading"%tCifInName
                sys.exit()
            else:
                allPdbLines  = tPdbIn.readlines()
                tPdbIn.close()
                for aLine in allPdbLines:
                    aLine = aLine.strip()
                    if aLine.find("ATOM") !=-1 or aLine.find("HETATM") !=-1 :
                        tName = aLine[12:16].strip()
                        tX    = aLine[30:38].strip()
                        tY    = aLine[38:46].strip()
                        tZ    = aLine[46:54].strip()
                        pdbAtoms[tName] = []
                        pdbAtoms[tName].append(tX)
                        pdbAtoms[tName].append(tY)
                        pdbAtoms[tName].append(tZ)

                allCifLines = tCifIn.readlines()
                tCifIn.close()
                lStart = True
                lAtom  = False
                lOther = False

                for aLine in allCifLines:
                    if aLine.find("_chem_comp_atom.z") != -1:
                        cifCont['head'].append(aLine)
                        lStart = False
                        lAtom  = True
                    elif lAtom and aLine.find("loop") != -1:
                        lAtom  = False
                        lOther = True
                        cifCont['others'].append(aLine)
                    elif lStart:  
                        cifCont['head'].append(aLine)
                    elif lAtom:
                        strGrp = aLine.split()
                        tName  = strGrp[1].strip()
                        if pdbAtoms.has_key(tName):
                            bLine = "%s%s%s%s%s%s%s%s\n"%(strGrp[0].ljust(8), tName.ljust(8), strGrp[2].ljust(8), \
                                                        strGrp[3].ljust(8), strGrp[4].ljust(8), \
                                                        pdbAtoms[tName][0].ljust(12), pdbAtoms[tName][1].ljust(12), \
                                                        pdbAtoms[tName][2].ljust(12)) 
                            cifCont['atoms'].append(bLine)
                        else: 
                            print "Bug. can not find atom %s in Pdb file %s "%(tName, tPdbInName) 
                            sys.exit()
                    elif lOther:
                        cifCont['others'].append(aLine)
  
                try:
                    tOutCif = open(tCifOutName, "w")
                except IOError:
                    print "%s can not be opened for reading"%tCifOutName
                    sys.exit()
                else:
                    for aL in cifCont['head']:
                        tOutCif.write(aL)
                    for aL in cifCont['atoms']:
                        tOutCif.write(aL)
                    for aL in cifCont['others']:
                        tOutCif.write(aL)
                    tOutCif.close()
                        
    def execute(self):
       
        self.printJobs()
        if self.workMode == 11:

            # Stage 1: dictionary generation using a mmcif file 
            if os.path.isfile(self.inMmCifName):
                self.runLibmol(self.inMmCifName)
            else:
                print "%s does not exist"%self.inMmCifName
                sys.exit()

            # Stage 2: optimization
            self.runGeoOpt()            
    
        if self.workMode == 12:
            
            # Stage 1: Transfer the SMILE input into a mmcif file
            if os.path.isfile(self.inSmiName):
                self.runLibcheck(self.inSmiName)
            else:
                print "%s does not exist"%self.inSmiName
                sys.exit()

            # Stage 2: dictionary generation using a mmcif file
            if os.path.isfile(self.libcheckLibName):
                self.runLibmol(self.libcheckLibName)
            else:
                print "%s does not exist"%self.inMmCifName
                sys.exit()

            # Stage 3: optimization
            self.runGeoOpt()            

        if self.workMode == 13:
            
            # Stage 1: dictionary generation using  a mdl file
            if os.path.isfile(self.inMdlName):
                self.runLibmol(self.inMdlName)
            else:
                print "can not find %s to read "%self.inMdlName
                sys.exit() 
 
            # Stage 2: optimization
            self.runGeoOpt()            
    
        if self.workMode == 14:
            
            # Stage 1: dictionary generation using  a sdf file
            if os.path.isfile(self.inSdfName):
                self.runLibmol(self.inSdfName)
            else:
                print "%s does not exist"%self.inSdfName
                sys.exit()
            
            # Stage 2: optimization
            self.runGeoOpt()            

        if self.workMode == 21:
            
            # Stage 1: generate molecules and the associated bond and bond-angle values 
            # using a small molecule cif file
            print "Generate molecules, bonds and angles from small molecule CIF file ", self.inStdCifName 
            if os.path.isfile(self.inStdCifName):
                self.runLibmol(self.inStdCifName)
            else:
                print "Can not find the input file ", self.inStdCifName 
            

def main():
    acedrgObj = Acedrg(sys.argv[1:])

if __name__ == "__main__":
    main()

